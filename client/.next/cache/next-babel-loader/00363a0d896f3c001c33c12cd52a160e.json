{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar Wave = function () {\n  'use strict';\n\n  function fromElement(element_id, canvas_id, options) {\n    const globalAccessKey = [options.globalAccessKey || '$wave'];\n\n    const initGlobalObject = elementId => {\n      window[globalAccessKey] = window[globalAccessKey] || {};\n      window[globalAccessKey][elementId] = window[globalAccessKey][elementId] || {};\n    };\n\n    const getGlobal = options['getGlobal'] || function (elementId, accessKey) {\n      initGlobalObject(elementId);\n      return window[globalAccessKey][elementId][accessKey];\n    };\n\n    const setGlobal = options['setGlobal'] || function (elementId, accessKey, value) {\n      let returnValue = getGlobal(elementId);\n\n      if (!returnValue) {\n        window[globalAccessKey][elementId][accessKey] = window[globalAccessKey][elementId][accessKey] || value;\n        returnValue = window[globalAccessKey][elementId][accessKey];\n      }\n\n      return returnValue;\n    };\n\n    const waveContext = this;\n    let element = document.getElementById(element_id);\n    if (!element) return;\n    element.crossOrigin = \"anonymous\";\n\n    function run() {\n      //user gesture has happened\n      this.activated = true; //track current wave for canvas\n\n      this.activeCanvas = this.activeCanvas || {};\n      this.activeCanvas[canvas_id] = JSON.stringify(options); //track elements used so multiple elements use the same data\n\n      this.activeElements[element_id] = this.activeElements[element_id] || {};\n      if (this.activeElements[element_id].count) this.activeElements[element_id].count += 1;else this.activeElements[element_id].count = 1;\n      const currentCount = this.activeElements[element_id].count;\n      const audioCtx = setGlobal(element.id, 'audioCtx', new AudioContext());\n      const analyser = setGlobal(element.id, 'analyser', audioCtx.createAnalyser());\n      let source = getGlobal(element.id, 'source');\n\n      if (source) {\n        if (source.mediaElement !== element) {\n          source = audioCtx.createMediaElementSource(element);\n        }\n      } else {\n        source = audioCtx.createMediaElementSource(element);\n      }\n\n      setGlobal(element.id, 'source', source); //beep test for ios\n\n      const oscillator = audioCtx.createOscillator();\n      oscillator.frequency.value = 1;\n      oscillator.connect(audioCtx.destination);\n      oscillator.start(0);\n      oscillator.stop(0);\n      source.connect(analyser);\n      source.connect(audioCtx.destination);\n      analyser.fftsize = 32768;\n      const bufferLength = analyser.frequencyBinCount;\n      const data = new Uint8Array(bufferLength);\n      let frameCount = 1;\n\n      function renderFrame() {\n        //only run one wave visual per canvas\n        if (JSON.stringify(options) !== this.activeCanvas[canvas_id]) {\n          return;\n        } //if the element or canvas go out of scope, stop animation\n\n\n        if (!document.getElementById(element_id) || !document.getElementById(canvas_id)) return;\n        requestAnimationFrame(renderFrame);\n        frameCount++; //check if this element is the last to be called\n\n        if (!(currentCount < this.activeElements[element_id].count)) {\n          analyser.getByteFrequencyData(data);\n          this.activeElements[element_id].data = data;\n        }\n\n        this.visualize(this.activeElements[element_id].data, canvas_id, options, frameCount);\n      }\n\n      renderFrame = renderFrame.bind(this);\n      renderFrame();\n    }\n\n    const create = () => {\n      //remove all events\n      [\"touchstart\", \"touchmove\", \"touchend\", \"mouseup\", \"click\", \"play\"].forEach(event => {\n        element.removeEventListener(event, create, {\n          once: true\n        });\n      });\n      run.call(waveContext);\n    };\n\n    if (this.activated || options['skipUserEventsWatcher']) {\n      run.call(waveContext);\n    } else {\n      //wait for a valid user gesture\n      document.body.addEventListener(\"touchstart\", create, {\n        once: true\n      });\n      document.body.addEventListener(\"touchmove\", create, {\n        once: true\n      });\n      document.body.addEventListener(\"touchend\", create, {\n        once: true\n      });\n      document.body.addEventListener(\"mouseup\", create, {\n        once: true\n      });\n      document.body.addEventListener(\"click\", create, {\n        once: true\n      });\n      element.addEventListener(\"play\", create, {\n        once: true\n      });\n    }\n  }\n\n  function fromFile(file, options = {}) {\n    //options\n    if (!options.stroke) options.stroke = 10;\n    let audio = new Audio();\n    audio.src = file;\n    let audioCtx = new AudioContext();\n    let analyser = audioCtx.createAnalyser();\n    let source = audioCtx.createMediaElementSource(audio);\n    source.connect(analyser);\n    analyser.fftSize = 64;\n    let bufferLength = analyser.frequencyBinCount;\n    let file_data;\n    let temp_data = new Uint8Array(bufferLength);\n    let getWave;\n    let fdi = 0;\n    let self = this;\n    audio.addEventListener('loadedmetadata', async function () {\n      while (audio.duration === Infinity) {\n        await new Promise(r => setTimeout(r, 1000));\n        audio.currentTime = 10000000 * Math.random();\n      }\n\n      audio.currentTime = 0;\n      audio.play();\n    });\n\n    audio.onplay = function () {\n      let findSize = size => {\n        for (let range = 1; range <= 40; range++) {\n          let power = 2 ** range;\n          if (size <= power) return power;\n        }\n      };\n\n      let d = audio.duration;\n      audio.playbackRate = 16;\n      d = d / audio.playbackRate;\n      let drawRate = 20; //ms\n\n      let size = d / (drawRate / 1000) * (analyser.fftSize / 2);\n      size = findSize(size);\n      file_data = new Uint8Array(size);\n      getWave = setInterval(function () {\n        analyser.getByteFrequencyData(temp_data);\n\n        for (let data in temp_data) {\n          data = temp_data[data];\n          file_data[fdi] = data;\n          fdi++;\n        }\n      }, drawRate);\n    };\n\n    audio.onended = function () {\n      if (audio.currentTime === audio.duration && file_data !== undefined) {\n        clearInterval(getWave);\n        let canvas = document.createElement(\"canvas\");\n        canvas.height = window.innerHeight;\n        canvas.width = window.innerWidth;\n        self.visualize(file_data, canvas, options);\n        let image = canvas.toDataURL(\"image/jpg\");\n        self.onFileLoad(image);\n        canvas.remove();\n      }\n    };\n  }\n\n  function fromStream(stream, canvas_id, options = {}) {\n    this.current_stream.id = canvas_id;\n    this.current_stream.options = options;\n    let audioCtx, analyser, source;\n\n    if (!this.sources[stream.toString()]) {\n      audioCtx = new AudioContext();\n      analyser = audioCtx.createAnalyser();\n      source = audioCtx.createMediaStreamSource(stream);\n      source.connect(analyser);\n      source.connect(audioCtx.destination); //playback audio\n\n      this.sources[stream.toString()] = {\n        \"audioCtx\": audioCtx,\n        \"analyser\": analyser,\n        \"source\": source\n      };\n    } else {\n      cancelAnimationFrame(this.sources[stream.toString()].animation);\n      audioCtx = this.sources[stream.toString()].audioCtx;\n      analyser = this.sources[stream.toString()].analyser;\n      source = this.sources[stream.toString()].source;\n    }\n\n    analyser.fftsize = 32768;\n    let bufferLength = analyser.frequencyBinCount;\n    this.current_stream.data = new Uint8Array(bufferLength);\n    let self = this;\n\n    function renderFrame() {\n      self.current_stream.animation = requestAnimationFrame(self.current_stream.loop);\n      self.sources[stream.toString()].animation = self.current_stream.animation;\n      analyser.getByteFrequencyData(self.current_stream.data);\n      self.visualize(self.current_stream.data, self.current_stream.id, self.current_stream.options);\n    }\n\n    this.current_stream.loop = renderFrame;\n    renderFrame();\n  }\n\n  function stopStream() {\n    cancelAnimationFrame(this.current_stream.animation);\n  }\n\n  function playStream() {\n    this.current_stream.loop();\n  }\n\n  var fromStream$1 = {\n    fromStream,\n    stopStream,\n    playStream\n  };\n\n  var drawWave = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    const helper = new Helper(ctx); // data = helper.mutateData(data, \"shrink\", 200)\n\n    data = helper.mutateData(data, \"split\", 4)[0];\n    data = helper.mutateData(data, \"scale\", h);\n    let points = helper.getPoints(\"line\", w, [0, h], data.length, data, {\n      offset: 100\n    });\n    points.start = points.start.slice(0, points.end.length - 1);\n    points.start.push([w, h]);\n    points.start.push([0, h]);\n    helper.drawPolygon(points.start, {\n      lineColor: colors[0],\n      color: colors[1],\n      radius: h * .008\n    });\n  };\n\n  var drawShine = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let cx = w / 2;\n    let cy = h / 2;\n    let r = h / 4;\n    let percent = (h / 2 - r) / 255;\n    let point_count = 512;\n    let increase = 360 / point_count * Math.PI / 180;\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = data[600 % point]; //get value\n\n      p *= percent;\n      point++; //start at 1\n\n      let a = point * increase;\n      let sx = cx + r * Math.cos(a);\n      let sy = cy + r * Math.sin(a);\n      ctx.moveTo(sx, sy);\n      let dx = cx + (r + p) * Math.cos(a);\n      let dy = cy + (r + p) * Math.sin(a);\n      ctx.lineTo(dx, dy);\n    }\n\n    ctx.stroke();\n\n    if (options.colors[1]) {\n      ctx.arc(cx, cy, r * .90, 0, 2 * Math.PI);\n      ctx.fillStyle = options.colors[1];\n      ctx.fill();\n    }\n  };\n\n  var drawRing = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let cx = w / 2;\n    let cy = h / 2;\n    let r = (h - 10) / 2;\n    let offset = r / 5;\n    let percent = (r - offset) / 255;\n    let point_count = 150;\n    let increase = 360 / point_count * Math.PI / 180;\n    ctx.arc(cx, cy, r, 0, 2 * Math.PI, true);\n    let fa = 0;\n    let fx = cx + (r - data[0] * percent) * Math.cos(fa);\n    let fy = cy + (r - data[0] * percent) * Math.sin(fa);\n    ctx.moveTo(fx, fy);\n    let q = 0;\n\n    for (let point = 0; point < point_count; point++) {\n      q += 1;\n\n      if (point >= point_count / 2) {\n        q -= 2;\n      }\n\n      let p = data[q]; //get value\n\n      p *= percent;\n      let a = point * increase;\n      let x = cx + (r - p) * Math.cos(a);\n      let y = cy + (r - p) * Math.sin(a);\n      ctx.lineTo(x, y);\n      ctx.arc(x, y, 2, 0, 2 * Math.PI);\n    }\n\n    ctx.lineTo(fx, fy);\n    ctx.stroke();\n    ctx.fillStyle = options.colors[1] || \"#fff0\";\n    ctx.fill();\n  };\n\n  var drawBars = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let point_count = 64;\n    let percent = h / 255;\n    let increase = w / 64;\n    let breakpoint = Math.floor(point_count / options.colors.length);\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = data[point]; //get value\n\n      p *= percent;\n      let x = increase * point;\n      ctx.moveTo(x, h);\n      ctx.lineTo(x, h - p);\n\n      if (point % breakpoint === 0) {\n        let i = point / breakpoint - 1;\n        ctx.strokeStyle = options.colors[i];\n        ctx.stroke();\n        ctx.beginPath();\n      }\n    }\n  };\n\n  var drawDualbars = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let percent = h / 255;\n    let increase = w / 128;\n    let point_count = 128;\n    let min = 5;\n    let breakpoint = Math.floor(point_count / options.colors.length);\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = data[point]; //get value\n\n      p += min;\n      p *= percent;\n      let x = increase * point;\n      let mid = h / 2 + p / 2;\n      ctx.moveTo(x, mid);\n      ctx.lineTo(x, mid - p);\n\n      if (point % breakpoint === 0) {\n        let i = point / breakpoint - 1;\n        ctx.strokeStyle = options.colors[i];\n        ctx.stroke();\n        ctx.beginPath();\n      }\n    }\n  };\n\n  var drawOrbs = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    const helper = new Helper(ctx);\n    data = helper.mutateData(data, \"organize\").mids;\n    data = helper.mutateData(data, \"split\", 2)[0];\n    data = helper.mutateData(data, \"shrink\", 100);\n    data = helper.mutateData(data, \"mirror\");\n    data = helper.mutateData(data, \"scale\", h);\n    data = helper.mutateData(data, \"amp\", .75);\n    let points = helper.getPoints(\"line\", w, [0, h / 2], data.length, data, {\n      offset: 50\n    });\n    points.start.forEach((start, i) => {\n      helper.drawLine(start, points.end[i], {\n        lineColor: colors[0]\n      });\n      helper.drawCircle(start, h * .01, {\n        color: colors[1] || colors[0]\n      });\n      helper.drawCircle(points.end[i], h * .01, {\n        color: colors[1] || colors[0]\n      });\n    });\n  };\n\n  var drawFlower = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let min = 5;\n    let r = h / 4;\n    let offset = r / 2;\n    let cx = w / 2;\n    let cy = h / 2;\n    let point_count = 128;\n    let percent = (r - offset) / 255;\n    let increase = 360 / point_count * Math.PI / 180;\n    let breakpoint = Math.floor(point_count / options.colors.length);\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = (data[point] + min) * percent;\n      let a = point * increase;\n      let sx = cx + (r - (p - offset)) * Math.cos(a);\n      let sy = cy + (r - (p - offset)) * Math.sin(a);\n      ctx.moveTo(sx, sy);\n      let dx = cx + (r + p) * Math.cos(a);\n      let dy = cy + (r + p) * Math.sin(a);\n      ctx.lineTo(dx, dy);\n\n      if (point % breakpoint === 0) {\n        let i = point / breakpoint - 1;\n        ctx.strokeStyle = options.colors[i];\n        ctx.stroke();\n        ctx.beginPath();\n      }\n    }\n\n    ctx.stroke();\n  };\n\n  var drawFlowerBlocks = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let r = h / 4;\n    let cx = w / 2;\n    let cy = h / 2;\n    let point_count = 56;\n    let percent = r / 255;\n    let increase = 360 / point_count * Math.PI / 180;\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = data[point] * percent;\n      let a = point * increase;\n      let ax = cx + (r - p / 2) * Math.cos(a);\n      let ay = cy + (r - p / 2) * Math.sin(a);\n      ctx.moveTo(ax, ay);\n      let bx = cx + (r + p) * Math.cos(a);\n      let by = cy + (r + p) * Math.sin(a);\n      ctx.lineTo(bx, by);\n      let dx = cx + (r + p) * Math.cos(a + increase);\n      let dy = cy + (r + p) * Math.sin(a + increase);\n      ctx.lineTo(dx, dy);\n      let ex = cx + (r - p / 2) * Math.cos(a + increase);\n      let ey = cy + (r - p / 2) * Math.sin(a + increase);\n      ctx.lineTo(ex, ey);\n      ctx.lineTo(ax, ay);\n    }\n\n    if (options.colors[1]) {\n      ctx.fillStyle = options.colors[1];\n      ctx.fill();\n    }\n\n    ctx.stroke();\n  };\n\n  var drawBarsBlocks = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let percent = h / 255;\n    let width = w / 64;\n\n    for (let point = 0; point < 64; point++) {\n      let p = data[point]; //get value\n\n      p *= percent;\n      let x = width * point;\n      ctx.rect(x, h, width, -p);\n    }\n\n    ctx.fillStyle = options.colors[1] || options.colors[0];\n    ctx.stroke();\n    ctx.fill();\n  };\n\n  var drawDualbarsBlocks = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let percent = h / 255;\n    let width = w / 50;\n\n    for (let point = 0; point <= 50; point++) {\n      let p = data[point]; //get value\n\n      p *= percent;\n      let x = width * point;\n      ctx.rect(x, h / 2 + p / 2, width, -p);\n    }\n\n    if (options.colors[1]) {\n      ctx.fillStyle = options.colors[1];\n      ctx.fill();\n    }\n\n    ctx.stroke();\n  };\n\n  var drawStar = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let r = h / 4;\n    let offset = r / 4;\n    let cx = w / 2;\n    let cy = h / 2;\n    let point_count = 120;\n    let percent = (r - offset - 35) / 255;\n    let increase = 360 / point_count * Math.PI / 180;\n    let top = [];\n    let bottom = [];\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = data[200 % point] * percent;\n      let a = point * increase;\n      let sx = cx + (r - p + offset) * Math.cos(a);\n      let sy = cy + (r - p + offset) * Math.sin(a);\n      ctx.moveTo(sx, sy);\n      bottom.push({\n        x: sx,\n        y: sy\n      });\n      let dx = cx + (r + p + offset) * Math.cos(a);\n      let dy = cy + (r + p + offset) * Math.sin(a);\n      ctx.lineTo(dx, dy);\n      top.push({\n        x: dx,\n        y: dy\n      });\n    }\n\n    ctx.moveTo(top[0].x, top[0].y);\n\n    for (let t in top) {\n      t = top[t];\n      ctx.lineTo(t.x, t.y);\n    }\n\n    ctx.closePath();\n    ctx.moveTo(bottom[0].x, bottom[0].y);\n\n    for (let b = bottom.length - 1; b >= 0; b++) {\n      b = bottom[b];\n      ctx.lineTo(b.x, b.y);\n    }\n\n    ctx.closePath();\n\n    if (options.colors[1]) {\n      ctx.fillStyle = options.colors[1];\n      ctx.fill();\n    }\n\n    ctx.stroke(); //inner color\n\n    ctx.beginPath();\n    ctx.moveTo(bottom[0].x, bottom[0].y);\n\n    for (let b in bottom) {\n      b = bottom[b];\n      ctx.lineTo(b.x, b.y);\n    }\n\n    ctx.closePath();\n\n    if (options.colors[2]) {\n      ctx.fillStyle = options.colors[2];\n      ctx.fill();\n    }\n\n    ctx.stroke();\n  };\n\n  var drawRoundWave = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w\n    } = functionContext;\n    let r = h / 4;\n    let cx = w / 2;\n    let cy = h / 2;\n    let point_count = 100;\n    let percent = r / 255;\n    let increase = 360 / point_count * Math.PI / 180;\n    let p = 0; // let z = (data[0] + min + offset) * percent;\n\n    let sx = cx + (r + p) * Math.cos(0);\n    let sy = cy + (r + p) * Math.sin(0);\n    ctx.moveTo(sx, sy);\n\n    for (let point = 1; point <= point_count; point++) {\n      let p = data[350 % point] * percent;\n      let a = point * increase;\n      let dx = cx + (r + p) * Math.cos(a);\n      let dy = cy + (r + p) * Math.sin(a);\n      ctx.lineTo(dx, dy);\n    }\n\n    ctx.closePath();\n    ctx.stroke();\n\n    if (options.colors[1]) {\n      ctx.fillStyle = options.colors[1];\n      ctx.fill();\n    }\n  };\n\n  var drawRings = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    let helper = new Helper(ctx);\n    let minDimension = h < w ? h : w;\n    data = helper.mutateData(data, \"organize\");\n    data = [data.mids, data.vocals];\n    data[0] = helper.mutateData(data[0], \"scale\", minDimension / 4);\n    data[1] = helper.mutateData(data[1], \"scale\", minDimension / 8);\n    data[0] = helper.mutateData(data[0], \"shrink\", 1 / 5);\n    data[0] = helper.mutateData(data[0], \"split\", 2)[0];\n    data[0] = helper.mutateData(data[0], \"reverb\");\n    data[1] = helper.mutateData(data[1], \"reverb\");\n    let outerCircle = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data[0].length, data[0]);\n    let innerCircle = helper.getPoints(\"circle\", minDimension / 4, [w / 2, h / 2], data[1].length, data[1]);\n    helper.drawPolygon(outerCircle.end, {\n      close: true,\n      radius: 4,\n      lineColor: colors[0],\n      color: colors[1]\n    });\n    helper.drawPolygon(innerCircle.end, {\n      close: true,\n      radius: 4,\n      lineColor: colors[2],\n      color: colors[3]\n    });\n    let middle = (minDimension / 4 + minDimension / 2) / 2;\n    let largerInner = data[1] = helper.mutateData(data[1], \"scale\", minDimension / 4 - minDimension / 2);\n    let innerBars = helper.getPoints(\"circle\", middle, [w / 2, h / 2], data[1].length, largerInner);\n    innerBars.start.forEach((start, i) => {\n      helper.drawLine(start, innerBars.end[i], {\n        lineColor: colors[4] || colors[2]\n      });\n    });\n  };\n\n  var drawShineRings = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    let helper = new Helper(ctx);\n    let minDimension = h < w ? h : w;\n    data = helper.mutateData(data, \"organize\");\n    data.vocals = helper.mutateData(data.vocals, \"scale\", minDimension / 2 / 2);\n    data.base = helper.mutateData(data.base, \"scale\", minDimension / 2 / 2);\n    let outerBars = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.vocals.length, data.vocals);\n    let innerWave = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.vocals.length, data.vocals, {\n      offset: 100\n    });\n    let thinLine = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.base.length, data.base, {\n      offset: 100\n    });\n    outerBars.start.forEach((start, i) => {\n      helper.drawLine(start, outerBars.end[i], {\n        lineColor: colors[0]\n      });\n    });\n    helper.drawPolygon(innerWave.start, {\n      close: true,\n      lineColor: colors[1],\n      color: colors[3],\n      radius: 5\n    });\n    helper.drawPolygon(thinLine.start, {\n      close: true,\n      lineColor: colors[2],\n      color: colors[4],\n      radius: 5\n    });\n  };\n\n  var drawCubes = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    let helper = new Helper(ctx);\n    data = helper.mutateData(data, \"organize\").base;\n    data = helper.mutateData(data, \"shrink\", 20).slice(0, 19);\n    data = helper.mutateData(data, \"scale\", h);\n    let points = helper.getPoints(\"line\", w, [0, h], data.length, data);\n    let spacing = 5;\n    let squareSize = w / 20 - spacing;\n    let colorIndex = 0;\n    points.start.forEach((start, i) => {\n      let squareCount = Math.ceil(data[i] / squareSize); //find color stops from total possible squares in bar\n\n      let totalSquares = (h - spacing * (h / squareSize)) / squareSize;\n      let colorStop = Math.ceil(totalSquares / colors.length);\n\n      for (let j = 1; j <= squareCount; j++) {\n        let origin = [start[0], start[1] - squareSize * j - spacing * j];\n        helper.drawSquare(origin, squareSize, {\n          color: colors[colorIndex],\n          lineColor: \"black\"\n        });\n\n        if (j % colorStop == 0) {\n          colorIndex++;\n          if (colorIndex >= colors.length) colorIndex = colors.length - 1;\n        }\n      }\n\n      colorIndex = 0;\n    });\n  };\n\n  var drawBigBars = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    const helper = new Helper(ctx);\n    data = helper.mutateData(data, \"organize\").vocals;\n    data = helper.mutateData(data, \"shrink\", 10);\n    data = helper.mutateData(data, \"scale\", h);\n    data = helper.mutateData(data, \"amp\", 1);\n    let points = helper.getPoints(\"line\", w, [0, h / 2], data.length, data, {\n      offset: 50\n    });\n    let colorIndex = 0;\n    let colorStop = Math.ceil(data.length / colors.length);\n    points.start.forEach((start, i) => {\n      if ((i + 1) % colorStop == 0) colorIndex++;\n      helper.drawRectangle(start, data[i], w / data.length, {\n        color: colors[colorIndex]\n      });\n    });\n  };\n\n  var drawShockwave = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    let helper = new Helper(ctx);\n    data = helper.mutateData(data, \"shrink\", 300);\n    data = helper.mutateData(data, \"scale\", h / 2);\n    data = helper.mutateData(data, \"split\", 4).slice(0, 3);\n    let colorIndex = 0;\n    data.forEach(points => {\n      let wavePoints = helper.getPoints(\"line\", w, [0, h / 2], points.length, points);\n      helper.drawPolygon(wavePoints.end, {\n        lineColor: colors[colorIndex],\n        radius: h * .015\n      });\n      let invertedPoints = helper.getPoints(\"line\", w, [0, h / 2], points.length, points, {\n        offset: 100\n      });\n      helper.drawPolygon(invertedPoints.start, {\n        lineColor: colors[colorIndex],\n        radius: h * .015\n      });\n      colorIndex++;\n    });\n  };\n\n  var drawFireworks = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    const helper = new Helper(ctx);\n    data = helper.mutateData(data, \"shrink\", 200).slice(0, 120);\n    data = helper.mutateData(data, \"mirror\");\n    data = helper.mutateData(data, \"scale\", h / 4 + h / 4 * .35);\n    let points = helper.getPoints(\"circle\", h / 2, [w / 2, h / 2], data.length, data, {\n      offset: 35,\n      rotate: 270\n    });\n    points.start.forEach((start, i) => {\n      helper.drawLine(start, points.end[i]);\n    });\n    helper.drawPolygon(points.start, {\n      close: true\n    });\n    points.end.forEach((end, i) => {\n      helper.drawCircle(end, h * .01, {\n        color: colors[0]\n      });\n    });\n  };\n\n  var drawStatic = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let helper = new Helper(ctx);\n    data = helper.mutateData(data, \"shrink\", 1 / 8);\n    data = helper.mutateData(data, \"split\", 2)[0];\n    data = helper.mutateData(data, \"scale\", h);\n    let points = helper.getPoints(\"line\", w, [0, h / 2], data.length, data, {\n      offset: 50\n    });\n    let prevPoint = null;\n    points.start.forEach((start, i) => {\n      if (prevPoint) {\n        helper.drawLine(prevPoint, start);\n      }\n\n      helper.drawLine(start, points.end[i]);\n      prevPoint = points.end[i];\n    });\n  };\n\n  var drawWeb = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let {\n      colors\n    } = options;\n    const helper = new Helper(ctx);\n    let minDimension = h < w ? h : w;\n    data = helper.mutateData(data, \"shrink\", 100);\n    data = helper.mutateData(data, \"split\", 2)[0];\n    data = helper.mutateData(data, \"scale\", h / 4);\n    let dataCopy = data;\n    let points = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.length, data);\n    helper.drawPolygon(points.end, {\n      close: true\n    });\n    points.start.forEach((start, i) => {\n      helper.drawLine(start, points.end[i]);\n    });\n    data = helper.mutateData(data, \"scale\", .7);\n    points = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.length, data);\n    helper.drawPolygon(points.end, {\n      close: true\n    });\n    data = helper.mutateData(data, \"scale\", .3);\n    points = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.length, data);\n    helper.drawPolygon(points.end, {\n      close: true\n    });\n    helper.drawCircle([w / 2, h / 2], minDimension / 2, {\n      color: colors[2]\n    });\n    dataCopy = helper.mutateData(dataCopy, \"scale\", 1.4);\n    points = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], dataCopy.length, dataCopy);\n    points.end.forEach((end, i) => {\n      helper.drawCircle(end, minDimension * .01, {\n        color: colors[1],\n        lineColor: colors[1] || colors[0]\n      });\n    });\n  };\n\n  var drawStitches = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper\n    } = functionContext;\n    let helper = new Helper(ctx);\n    let minDimension = h < w ? h : w;\n    data = helper.mutateData(data, \"shrink\", 200);\n    data = helper.mutateData(data, \"split\", 2)[0];\n    data = helper.mutateData(data, \"scale\", h / 2);\n    let points = helper.getPoints(\"circle\", minDimension / 2, [w / 2, h / 2], data.length, data, {\n      offset: 50\n    });\n    helper.drawPolygon(points.end, {\n      close: true\n    });\n    helper.drawPolygon(points.start, {\n      close: true\n    });\n\n    for (let i = 0; i < points.start.length; i += 1) {\n      let start = points.start[i];\n      i++;\n      let end = points.end[i] || points.end[0];\n      helper.drawLine(start, end);\n      helper.drawLine(end, points.start[i + 1] || points.start[0]);\n    }\n  };\n\n  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : false ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var origami_1 = createCommonjsModule(function (module, exports) {\n    /*!\n     * Origami.js 0.5.0\n     * https://origamijs.com/\n     *\n     * Copyright Raphael Amorim 2016\n     * Released under the GPL-4.0 license\n     *\n     * Date: 2016-09-23T03:42Z\n     */\n    (function (window) {\n      /**\n       * Config object: Maintain internal state\n       * Later exposed as Origami.config\n       * `config` initialized at top of scope\n       */\n      var Origami = {\n        // Current Paper\n        paper: null\n      };\n      var config = {\n        // Document Styles\n        documentStyles: [],\n        // Virtual Styles\n        virtualStyles: {},\n        // All contexts saved\n        contexts: [],\n        // Origami Shapes Defaults\n        defaults: {\n          arc: {\n            background: 'rgba(0, 0, 0, 0)',\n            strokeStyle: 'rgba(0, 0, 0, 0)',\n            lineWidth: null\n          },\n          rect: {\n            background: 'rgba(0, 0, 0, 0)',\n            strokeStyle: 'rgba(0, 0, 0, 0)',\n            lineWidth: null\n          },\n          polygon: {\n            background: 'rgba(0, 0, 0, 0)',\n            strokeStyle: 'rgba(0, 0, 0, 0)',\n            lineWidth: null\n          },\n          line: {\n            strokeStyle: 'rgba(0, 0, 0, 0)',\n            lineWidth: null\n          },\n          text: {\n            font: '14px Helvetica',\n            strokeStyle: 'rgba(0, 0, 0, 0)',\n            color: '#000',\n            lineWidth: null\n          }\n        }\n      };\n      var prefix = \"[origami.js]\";\n\n      Origami.warning = function warning(message, obj) {\n        if (console && console.warn) console.warn(prefix, message, obj);\n      };\n\n      Origami.error = function error(message) {\n        throw new Error(prefix.concat(' ' + message));\n      };\n\n      Origami.init = function (el) {\n        if (el.canvas) {\n          el = el.canvas;\n        } else {\n          el = document.querySelector(el);\n        }\n\n        if (!el) this.error('Please use a valid selector or canvas context');\n        var existentContext = exists(el, config.contexts);\n\n        if (existentContext) {\n          this.paper = existentContext;\n          return this;\n        }\n\n        if (!el.getContext) this.error('Please verify if it\\'s a valid canvas element');\n        el.width = el.clientWidth;\n        el.height = el.clientHeight;\n        var context = el.getContext('2d');\n        var current = {\n          element: el,\n          queue: [],\n          index: config.contexts.length,\n          flip: false,\n          frame: null,\n          ctx: context,\n          width: el.width,\n          height: el.height\n        };\n        config.contexts.push(current);\n        this.paper = current;\n        return this;\n      };\n\n      Origami.styles = function () {\n        if (!config.virtualStyles.length) defineDocumentStyles();\n        var selectors = arguments;\n\n        if (!selectors.length) {\n          config.virtualStyles['empty'] = true;\n          return this;\n        }\n\n        for (var i = 0; i < selectors.length; i++) {\n          var style = styleRuleValueFrom(selectors[i], config.documentStyles[0] || []);\n          config.virtualStyles[selectors[i]] = style;\n        }\n\n        return this;\n      };\n\n      Origami.getPaper = function () {\n        return this.paper;\n      };\n\n      Origami.canvasCtx = function () {\n        return this.paper.ctx;\n      };\n\n      Origami.getContexts = function () {\n        return config.contexts;\n      };\n\n      Origami.cleanContexts = function () {\n        config.contexts = [];\n      };\n\n      Origami.createComponent = function (component, fn) {\n        Origami[component] = function (props) {\n          fn.bind(this, this, props)();\n          return this;\n        };\n      };\n\n      Origami.fn = {};\n\n      Origami.draw = function (options) {\n        var self = this,\n            customRender = false,\n            ctx = self.paper.ctx;\n\n        if (typeof options === 'string') {\n          customRender = new origami.fn[options](self.paper);\n          self.paper['ctx'] = customRender;\n        }\n\n        var abs = new Screen(self.paper),\n            queueList = self.paper.queue;\n\n        for (var i = 0; i < queueList.length; i++) {\n          if (queueList[i].loaded === false || queueList[i].failed) {\n            Origami.warning('couldn\\'t able to load:', queueList[i].params);\n          }\n\n          abs[queueList[i].assign](queueList[i].params);\n        }\n\n        self.paper.queue = [];\n\n        if (customRender) {\n          customRender.draw();\n          self.paper.ctx = ctx;\n        }\n\n        if (typeof options === 'function') options();\n      };\n\n      Origami.load = function (fn) {\n        var mOrigami = clone(this);\n        mOrigami.paper = this.paper;\n        var loadInterval = setInterval(function () {\n          var dataLoad = mOrigami.paper.queue.filter(function (item) {\n            return item.loaded === false && !item.failed;\n          }); // When already loaded\n\n          if (!dataLoad.length) {\n            clearInterval(loadInterval);\n            fn.bind(mOrigami, mOrigami)();\n          }\n        }, 1);\n      };\n\n      function Queue(assign, params, loaded) {\n        this.paper.queue.push({\n          assign: assign,\n          params: params,\n          loaded: loaded\n        });\n      }\n\n      var queue = Queue.bind(Origami); // Utilities.js\n\n      var hasOwn = Object.prototype.hasOwnProperty;\n      /**\n       * Check if element exists in a Array of NodeItems\n       * @param {NodeItem} current nodeItem to check\n       * @param {Array} array of NodeItems\n       * @returns {NodeItem} NodeItem exitent in array\n       */\n\n      function exists(el, arr) {\n        for (var i = 0; i < arr.length; i++) {\n          if (arr[i].element.isEqualNode(el)) return arr[i];\n        }\n\n        return false;\n      }\n      /**\n       * Filter arguments by rules\n       * @param {Array} methods arguments\n       * @param {Object} rules to apply\n       * @returns {Object} arguments filtered\n       */\n\n\n      function argsByRules(argsArray, rules) {\n        var params = rules || ['x', 'y', 'width', 'height'],\n            args = {};\n\n        for (var i = 0; i < argsArray.length; i++) {\n          if (typeof argsArray[i] === \"object\") args[\"style\"] = argsArray[i];else if (params.length) args[params.shift()] = argsArray[i];\n        }\n\n        args.style = normalizeStyle(args.style);\n        if (typeof args.x === 'string' && typeof args.y === 'string') args = smartCoordinates(args);\n        return args;\n      }\n\n      function getBorderStyleObject(prop) {\n        return normalizeStyle({\n          border: prop\n        });\n      }\n\n      function normalizeStyle(style) {\n        if (!style) style = {};\n        var borderSize = style.borderSize || null,\n            borderColor = style.borderColor || null,\n            borderStyle = style.borderStyle || [];\n\n        if (style.border) {\n          var border = [],\n              borderString = style.border; // 0 - Size: [0-9]px\n\n          border = border.concat(style.border.match(/[0-9]*\\.?[0-9]px?/i));\n          borderString = borderString.replace(/[0-9]*\\.?[0-9]px?/i, ''); // 1 - Style\n\n          border = border.concat(borderString.match(/solid|dashed|dotted/i));\n          borderString = borderString.replace(/solid|dashed|dotted/i, ''); // 2 - Color\n\n          border = border.concat(borderString.match(/[^\\s]+/i));\n          if (!borderSize) borderSize = border[0];\n          if (!borderColor) borderColor = border[2];\n          borderStyle = border[1];\n        }\n\n        if (borderSize) borderSize = borderSize.replace(/[^0-9]/g, '');\n\n        if (typeof borderStyle === 'string') {\n          if (borderStyle === 'dashed') borderStyle = [12];else if (borderStyle === 'dotted') borderStyle = [3];else borderStyle = [];\n        }\n\n        style['borderSize'] = borderSize;\n        style['borderStyle'] = borderStyle;\n        style['borderColor'] = borderColor;\n        return style;\n      }\n      /**\n       * Return args object with new coordinates based on behavior\n       * @returns {Object} args\n       */\n\n\n      function smartCoordinates(args) {\n        var x = args.x,\n            y = args.y;\n        var paper = Origami.getPaper(),\n            elmWidth = paper.element.width,\n            elmHeight = paper.element.height,\n            radius = args.r || 0;\n        var width = args.width || radius,\n            height = args.height || width;\n        var axis = {\n          x: ['right', 'center', 'left'],\n          y: ['top', 'center', 'bottom']\n        };\n\n        if (axis.x.indexOf(x) !== -1) {\n          if (x === 'right') x = Math.floor(elmWidth - width);else if (x === 'center') {\n            if (radius) x = Math.floor(elmWidth / 2);else x = Math.floor(elmWidth / 2 - width / 2);\n          } else if (x === 'left') x = radius;\n        } else if ((x + '').substr(-1) === '%') {\n          x = elmWidth * parseInt(x, 10) / 100;\n        } else {\n          x = 0;\n        }\n\n        if (axis.y.indexOf(y) !== -1) {\n          if (y === 'top') y = radius;else if (y === 'center') {\n            if (radius) y = Math.floor(elmHeight / 2);else y = Math.floor(elmHeight / 2 - height / 2);\n          } else if (y === 'bottom') y = Math.floor(elmHeight - height);\n        } else if ((y + '').substr(-1) === '%') {\n          y = elmHeight * parseInt(y, 10) / 100;\n        } else {\n          y = 0;\n        }\n\n        args.y = y;\n        args.x = x;\n        return args;\n      }\n      /**\n       * Return all documentStyles to a especified origami context\n       * @returns undefined\n       */\n\n\n      function defineDocumentStyles() {\n        for (var i = 0; i < document.styleSheets.length; i++) {\n          var mysheet = document.styleSheets[i],\n              myrules = mysheet.cssRules ? mysheet.cssRules : mysheet.rules;\n          config.documentStyles.push(myrules);\n        }\n      }\n      /**\n       * Merge defaults with user options\n       * @param {Object} defaults Default settings\n       * @param {Object} options User options\n       * @returns {Object} Merged values of defaults and options\n       */\n\n\n      function extend(a, b, undefOnly) {\n        for (var prop in b) {\n          if (hasOwn.call(b, prop)) {\n            // Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n            // This block runs on every environment, so `global` is being used instead of `window`\n            // to avoid errors on node.\n            if (prop !== \"constructor\" || a !== commonjsGlobal) {\n              if (b[prop] === undefined) {\n                delete a[prop];\n              } else if (!(undefOnly && typeof a[prop] !== \"undefined\")) {\n                a[prop] = b[prop];\n              }\n            }\n          }\n        }\n\n        return a;\n      }\n      /**\n       * Get Style Rule from a specified element\n       * @param {String} selector from element\n       * @param {Array} Document Style Rules\n       * @returns {Object} Merged values of defaults and options\n       */\n\n\n      function styleRuleValueFrom(selector, documentStyleRules) {\n        for (var j = 0; j < documentStyleRules.length; j++) {\n          if (documentStyleRules[j].selectorText && documentStyleRules[j].selectorText.toLowerCase() === selector) {\n            return documentStyleRules[j].style;\n          }\n        }\n      }\n      /**\n       * Clone a object\n       * @param {Object} object\n       * @returns {Object} cloned object\n       */\n\n\n      function clone(obj) {\n        if (null == obj || \"object\" != typeof obj) return obj;\n        var copy = obj.constructor();\n\n        for (var attr in obj) {\n          if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];\n        }\n\n        return copy;\n      }\n\n      function Screen(currentContext) {\n        this.paper = currentContext;\n      }\n\n      Screen.prototype.translate = function (params) {\n        this.paper.ctx.translate(params.x, params.y);\n      };\n\n      Screen.prototype.background = function (params) {\n        this.paper.element.style.backgroundColor = params.color;\n      };\n\n      Screen.prototype.restore = function () {\n        this.paper.ctx.restore();\n      };\n\n      Screen.prototype.save = function () {\n        this.paper.ctx.save();\n      };\n\n      Screen.prototype.composition = function (params) {\n        this.paper.ctx.globalCompositeOperation = params.globalComposite;\n      };\n\n      Screen.prototype.rotate = function (params) {\n        this.paper.ctx.rotate(params.degrees);\n      };\n\n      Screen.prototype.scale = function (params) {\n        this.paper.ctx.scale(params.width, params.height);\n      };\n\n      Screen.prototype.flip = function (params) {\n        this.paper.flip = 'horizontal';\n        if (params.type && typeof params.type === 'string') this.paper.flip = params.type;\n      };\n\n      Screen.prototype.flipEnd = function () {\n        this.paper.flip = false;\n      };\n\n      Screen.prototype.clear = function () {\n        this.paper.ctx.clearRect(0, 0, this.paper.width, this.paper.height);\n      };\n\n      function ArcShape(params) {\n        var args = params.args,\n            style = args.style,\n            def = config.defaults.arc;\n        this.paper.ctx.beginPath();\n        this.paper.ctx.setLineDash(style.borderStyle);\n        this.paper.ctx.arc(args.x, args.y, args.r || def.radius, args.sAngle || 0, args.eAngle || 2 * Math.PI);\n        this.paper.ctx.fillStyle = style.background || style.bg ? style.background || style.bg : def.background;\n        this.paper.ctx.fill();\n        this.paper.ctx.lineWidth = style.borderSize ? style.borderSize : def.lineWidth;\n        this.paper.ctx.strokeStyle = style.borderColor ? style.borderColor : def.strokeStyle;\n        this.paper.ctx.stroke();\n        this.paper.ctx.setLineDash([]);\n        this.paper.ctx.closePath();\n      }\n\n      Screen.prototype.arc = ArcShape;\n\n      Origami.arc = function () {\n        var args = [].slice.call(arguments);\n        args = argsByRules(args, ['x', 'y', 'r', 'sAngle', 'eAngle']);\n        queue('arc', {\n          args: args\n        });\n        return this;\n      };\n\n      function ImageShape(params) {\n        var image = params.image,\n            x = params.x,\n            y = params.y,\n            width = params.width,\n            height = params.height;\n        this.paper.ctx.save();\n\n        if (this.paper.flip) {\n          if (this.paper.flip === 'horizontal') {\n            this.paper.ctx.scale(-1, 1);\n            width = width * -1;\n            x = x * -1;\n          }\n\n          if (this.paper.flip === 'vertical') {\n            this.paper.ctx.scale(1, -1);\n            height = height * -1;\n            y = y * -1;\n          }\n        }\n\n        this.paper.ctx.beginPath();\n        this.paper.ctx.drawImage(image, Math.floor(x || 0), Math.floor(y || 0), width, height);\n        this.paper.ctx.closePath();\n        this.paper.ctx.restore();\n      }\n\n      Screen.prototype.image = ImageShape;\n\n      Origami.image = function (image, x, y, width, height) {\n        var self = this;\n        if (!image) return this;\n\n        if (typeof image === 'string') {\n          var img = new Image();\n          img.src = image;\n          image = img;\n        }\n\n        var item = {\n          image: image,\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        };\n        if (typeof item.x === 'string' && typeof item.y === 'string') item = smartCoordinates(item);\n\n        if (image.complete) {\n          item.width = width || image.naturalWidth;\n          item.height = height || image.naturalHeight;\n          queue('image', item);\n          return self;\n        }\n\n        queue('image', item, false);\n        var reference = self.paper.queue.length - 1,\n            currentQueue = config.contexts[this.paper.index].queue[reference];\n        image.addEventListener('load', function () {\n          if (!currentQueue) return false;\n          currentQueue.params.width = item.width || image.naturalWidth;\n          currentQueue.params.height = item.height || image.naturalHeight;\n          currentQueue.loaded = true;\n        });\n        image.addEventListener('error', function () {\n          if (!currentQueue) return false;\n          currentQueue.failed = true;\n        });\n        return self;\n      };\n\n      function LineShape(params) {\n        var def = config.defaults.line,\n            style = params.style,\n            pointA = params.pointA,\n            pointB = params.pointB;\n        this.paper.ctx.beginPath();\n        this.paper.ctx.setLineDash(style.borderStyle);\n        this.paper.ctx.moveTo(pointA.x || 0, pointA.y || 0);\n        this.paper.ctx.lineTo(pointB.x || 0, pointB.y || 0);\n        this.paper.ctx.lineWidth = style.borderSize ? style.borderSize : def.lineWidth;\n        this.paper.ctx.strokeStyle = style.borderColor ? style.borderColor : def.strokeStyle;\n        this.paper.ctx.stroke();\n        this.paper.ctx.setLineDash([]);\n        this.paper.ctx.closePath();\n      }\n\n      Screen.prototype.line = LineShape;\n\n      Origami.line = function (pointA, pointB, style) {\n        style = normalizeStyle(style);\n        queue('line', {\n          pointA: pointA,\n          pointB: pointB,\n          style: style\n        });\n        return this;\n      };\n\n      function PolygonShape(params) {\n        var args = params.args,\n            style = params.style,\n            def = config.defaults.polygon;\n        this.paper.ctx.beginPath();\n        this.paper.ctx.setLineDash(style.borderStyle);\n        this.paper.ctx.fillStyle = style.background ? style.background : def.background;\n        this.paper.ctx.lineWidth = style.borderSize ? style.borderSize : def.lineWidth;\n        this.paper.ctx.strokeStyle = style.borderColor ? style.borderColor : def.strokeStyle;\n\n        for (var p = 0; p < args.length; p++) {\n          if (!args[p].x) continue;\n          if (p) this.paper.ctx.lineTo(args[p].x, args[p].y);else this.paper.ctx.moveTo(args[p].x, args[p].y);\n        }\n\n        this.paper.ctx.fill();\n        this.paper.ctx.stroke();\n        this.paper.ctx.setLineDash([]);\n        this.paper.ctx.closePath();\n      }\n\n      Screen.prototype.polygon = PolygonShape;\n\n      Origami.polygon = function () {\n        var args = [].slice.call(arguments),\n            settedArgs = argsByRules(args);\n        queue('polygon', {\n          style: settedArgs.style,\n          args: args\n        });\n        return this;\n      };\n\n      function RectShape(params) {\n        var def = config.defaults.rect,\n            style = params.style,\n            args = params.args;\n        this.paper.ctx.beginPath();\n        this.paper.ctx.setLineDash(style.borderStyle);\n        this.paper.ctx.fillStyle = style.background ? style.background : def.background;\n        this.paper.ctx.fillRect(args.x, args.y, args.width, args.height || args.width);\n        this.paper.ctx.lineWidth = style.borderSize ? style.borderSize : def.lineWidth;\n        this.paper.ctx.strokeStyle = style.borderColor ? style.borderColor : def.strokeStyle;\n        this.paper.ctx.strokeRect(args.x, args.y, args.width, args.height || args.width);\n        this.paper.ctx.setLineDash([]);\n        this.paper.ctx.closePath();\n      }\n\n      Screen.prototype.rect = RectShape;\n\n      Origami.rect = function () {\n        var args = [].slice.call(arguments);\n        args = argsByRules(args);\n        queue('rect', {\n          style: args.style,\n          args: args\n        });\n        return this;\n      };\n\n      Origami.border = function () {\n        var args = [].slice.call(arguments);\n        args = argsByRules(args);\n        queue('rect', {\n          style: args.style,\n          args: {\n            x: 0,\n            y: 0,\n            width: this.paper.width,\n            height: this.paper.height\n          }\n        });\n        return this;\n      };\n\n      function CSSShape(style) {\n        var self = this,\n            style = config.virtualStyles[style];\n        if (!style) return self; // TODO: Draw in all canvas\n\n        var data = '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"' + self.paper.width + 'px\" height=\"' + self.paper.height + 'px\">' + '<foreignObject width=\"100%\" height=\"100%\">' + '<div xmlns=\"http://www.w3.org/1999/xhtml\">' + '<div style=\"' + style.cssText + '\"></div>' + '</div></foreignObject>' + '</svg>';\n        var DOMURL = window.URL || window.webkitURL || window,\n            img = new Image(),\n            svg = new Blob([data], {\n          type: 'image/svg+xml;charset=utf-8'\n        });\n        var url = DOMURL.createObjectURL(svg);\n        img.src = url;\n        img.addEventListener('load', function () {\n          self.paper.ctx.beginPath();\n          self.paper.ctx.drawImage(img, 0, 0);\n          DOMURL.revokeObjectURL(url);\n          self.paper.ctx.closePath();\n        });\n        return self;\n      }\n\n      Screen.prototype.CSSShape = CSSShape;\n\n      Origami.shape = function (style) {\n        queue('CSSShape', style);\n        return this;\n      };\n\n      function SpriteShape(params) {\n        var properties = params.properties,\n            dw = params.width / properties.frames;\n        drawSprite.call(this, {\n          image: params.image,\n          posX: 0,\n          posY: 0,\n          frame: properties.frames,\n          loop: properties.loop,\n          width: dw,\n          widthTotal: params.width,\n          height: params.height,\n          dx: params.x,\n          dy: params.y,\n          speed: properties.speed,\n          animation: null\n        });\n      }\n\n      function drawSprite(sprite) {\n        var self = this;\n\n        if (sprite.posX === sprite.widthTotal) {\n          if (sprite.loop === false) {\n            window.cancelAnimationFrame(sprite.animation);\n            return;\n          }\n\n          sprite.posX = 0;\n        }\n\n        self.paper.ctx.clearRect(sprite.dx, sprite.dy, sprite.width, sprite.height);\n        self.paper.ctx.beginPath();\n        self.paper.ctx.drawImage(sprite.image, sprite.posX, sprite.posY, sprite.width, sprite.height, sprite.dx, sprite.dy, sprite.width, sprite.height);\n        self.paper.ctx.closePath();\n        sprite.posX = sprite.posX + sprite.width;\n        setTimeout(function () {\n          sprite.animation = window.requestAnimationFrame(drawSprite.bind(self, sprite));\n        }, sprite.speed);\n      }\n\n      Screen.prototype.sprite = SpriteShape;\n\n      Origami.sprite = function (x, y, properties) {\n        var self = this;\n        if (!properties || !properties.src) return this;\n        var image = new Image(),\n            frames = properties.frames || 0,\n            loop = properties.loop || true,\n            speed = properties.speed || 10;\n        image.src = properties.src;\n        var item = {\n          x: x,\n          y: y,\n          image: image,\n          properties: properties,\n          width: 0,\n          height: 0\n        };\n\n        if (image.complete) {\n          item.width = image.naturalWidth;\n          item.height = image.naturalHeight;\n          queue('sprite', item);\n          return self;\n        }\n\n        queue('sprite', item, false);\n        var reference = self.paper.queue.length - 1,\n            currentQueue = config.contexts[this.paper.index].queue[reference];\n        image.addEventListener('load', function () {\n          if (!currentQueue) return false;\n          currentQueue.params.width = image.naturalWidth;\n          currentQueue.params.height = image.naturalHeight;\n          currentQueue.loaded = true;\n        });\n        image.addEventListener('error', function () {\n          if (!currentQueue) return false;\n          currentQueue.failed = true;\n        });\n        return this;\n      };\n\n      function TextShape(params) {\n        var def = config.defaults.text,\n            text = params.text,\n            x = params.x,\n            y = params.y,\n            style = params.style;\n        this.paper.ctx.beginPath();\n        this.paper.ctx.setLineDash(style.borderStyle);\n        this.paper.ctx.lineWidth = style.borderSize ? style.borderSize : def.lineWidth;\n        this.paper.ctx.strokeStyle = style.borderColor ? style.borderColor : def.strokeStyle;\n        this.paper.ctx.font = style.font || def.font;\n        this.paper.ctx.fillStyle = style.color || def.color;\n        this.paper.ctx.textAlign = style.align || def.align;\n        this.paper.ctx.fillText(text, x, y);\n        this.paper.ctx.strokeText(text, x, y);\n        this.paper.ctx.fill();\n        this.paper.ctx.stroke();\n        this.paper.ctx.setLineDash([]);\n        this.paper.ctx.closePath();\n      }\n\n      Screen.prototype.text = TextShape;\n\n      Origami.text = function (text, x, y, style) {\n        style = normalizeStyle(style);\n        var item = {\n          text: text,\n          x: x,\n          y: y,\n          style: style\n        };\n        if (typeof item.x === 'string' && typeof item.y === 'string') item = smartCoordinates(item);\n        queue('text', item);\n        return this;\n      };\n\n      function ChartLine(config) {\n        var ctx = this.paper.ctx,\n            width = this.paper.width,\n            height = this.paper.height;\n        var line = getBorderStyleObject(config.line || \"1px solid #000\");\n        var lineVariance = 2;\n        var xPadding = 40;\n        var yPadding = 40;\n        var data = [];\n        var gridLines = {\n          vertical: true,\n          horizontal: true\n        };\n\n        if (config.gridLines) {\n          if (config.gridLines.vertical === false) gridLines.vertical = false;\n          if (config.gridLines.horizontal === false) gridLines.horizontal = false;\n        }\n\n        for (var i = 0; i < config.labels.length; i++) {\n          data.push({\n            X: config.labels[i],\n            Y: config.data[i]\n          });\n        }\n\n        function getMaxY() {\n          var max = 0;\n\n          for (var i = 0; i < data.length; i++) {\n            if (data[i].Y > max) {\n              max = data[i].Y;\n            }\n          }\n\n          max += 10 - max % 10;\n          return max;\n        }\n\n        function getXPixel(val) {\n          return (width - xPadding) / data.length * val + xPadding;\n        }\n\n        function getYPixel(val) {\n          return height - (height - yPadding) / getMaxY() * val - yPadding;\n        }\n\n        ctx.lineWidth = 0.8;\n        ctx.strokeStyle = '#999';\n        ctx.font = 'normal 12px Helvetica';\n        ctx.fillStyle = '#5e5e5e';\n        ctx.textAlign = \"center\";\n        ctx.beginPath();\n        ctx.moveTo(xPadding, yPadding / lineVariance);\n        ctx.lineTo(xPadding, height - yPadding);\n        ctx.lineTo(width - xPadding / lineVariance, height - yPadding);\n        ctx.stroke(); // Data\n\n        ctx.textAlign = \"right\";\n        ctx.textBaseline = \"middle\";\n\n        for (var i = 0; i < getMaxY(); i += 10) {\n          if (gridLines.horizontal) {\n            ctx.beginPath();\n            ctx.lineWidth = 0.8;\n            ctx.strokeStyle = '#e7e7e7';\n            ctx.moveTo(xPadding - 5, getYPixel(i));\n            ctx.lineTo(width - xPadding / lineVariance, getYPixel(i));\n            ctx.stroke();\n          }\n\n          ctx.fillText(i, xPadding - 10, getYPixel(i));\n        } // Labels\n\n\n        ctx.textAlign = \"left\";\n\n        for (var i = 0; i < data.length; i++) {\n          if (gridLines.vertical) {\n            ctx.beginPath();\n            ctx.lineWidth = 0.8;\n            ctx.strokeStyle = '#e7e7e7';\n            ctx.moveTo(getXPixel(i), height - yPadding + 10);\n            ctx.lineTo(getXPixel(i), yPadding / lineVariance);\n            ctx.stroke();\n          }\n\n          ctx.fillText(data[i].X, getXPixel(i), height - yPadding + 20);\n        }\n\n        ctx.beginPath();\n        ctx.lineWidth = line.borderSize;\n        ctx.setLineDash(line.borderStyle);\n        ctx.strokeStyle = line.borderColor;\n        ctx.moveTo(getXPixel(0), getYPixel(data[0].Y));\n\n        for (var i = 1; i < data.length; i++) {\n          ctx.lineTo(getXPixel(i), getYPixel(data[i].Y));\n        }\n\n        ctx.stroke();\n        ctx.setLineDash([]);\n\n        if (config.points) {\n          ctx.fillStyle = config.pointsColor ? config.pointsColor : 'rgb(75,75,75)';\n\n          for (var i = 0; i < data.length; i++) {\n            ctx.beginPath();\n            ctx.arc(getXPixel(i), getYPixel(data[i].Y), 3, 0, Math.PI * 2, true);\n            ctx.fill();\n          }\n        }\n      }\n\n      Screen.prototype.chartLine = ChartLine;\n\n      Origami.chartLine = function (config) {\n        queue('chartLine', config);\n        return this;\n      }; // Resource.js\n\n\n      Origami.background = function (color) {\n        queue('background', {\n          color: color\n        });\n        return this;\n      };\n\n      Origami.restore = function () {\n        queue('restore');\n        return this;\n      };\n\n      Origami.save = function () {\n        queue('save');\n        return this;\n      };\n\n      Origami.composition = function (globalComposite) {\n        queue('composition', {\n          globalComposite: globalComposite\n        });\n        return this;\n      };\n\n      Origami.translate = function (x, y) {\n        if (x === undefined || x === null) {\n          x = 'reset';\n        }\n\n        if (typeof x === 'string') {\n          if (x === 'center') {\n            x = context.width / 2;\n            y = context.height / 2;\n          }\n\n          if (x === 'reset') {\n            x = -context.width / 2;\n            y = -context.height / 2;\n          }\n        }\n\n        queue('translate', {\n          x: x,\n          y: y\n        });\n        return this;\n      };\n\n      Origami.rotate = function (degrees) {\n        if (typeof degrees === 'undefined') degrees = 'slow';\n\n        if (typeof degrees === 'string') {\n          // Slow\n          if (degrees === 'slow') degrees = 2 * Math.PI / 60 * new Date().getSeconds() + 2 * Math.PI / 60000 * new Date().getMilliseconds(); // Normal\n          else if (degrees === 'normal') degrees = 2 * Math.PI / 30 * new Date().getSeconds() + 2 * Math.PI / 30000 * new Date().getMilliseconds(); // Fast\n          else if (degrees === 'fast') degrees = 2 * Math.PI / 6 * new Date().getSeconds() + 2 * Math.PI / 6000 * new Date().getMilliseconds();\n        }\n\n        queue('rotate', {\n          degrees: degrees\n        });\n        return this;\n      };\n\n      Origami.stopRender = function () {\n        window.cancelAnimationFrame(this.paper.frame);\n        this.paper.frame = false;\n      };\n\n      Origami.play = function () {\n        this.paper.frame = 1;\n        return this;\n      };\n\n      Origami.startRender = function (fn) {\n        var self = this;\n        if (self.paper.frame === false) return;\n        self.draw(function () {\n          self.paper.frame = window.requestAnimationFrame(fn.bind(this));\n        });\n      };\n\n      Origami.scale = function (width, height) {\n        queue('scale', {\n          width: width,\n          height: height\n        });\n        return this;\n      };\n\n      Origami.flip = function (type) {\n        queue('flip', {\n          type: type\n        });\n        return this;\n      };\n\n      Origami.flipEnd = function () {\n        queue('flipEnd');\n        return this;\n      };\n\n      Origami.clear = function () {\n        queue('clear');\n        return this;\n      };\n\n      Origami.on = function (ev, fn) {\n        this.paper.element.addEventListener(ev, fn);\n        return this;\n      };\n\n      var factory = extend(Origami.init.bind(this), Origami); // For consistency with CommonJS environments' exports\n\n      if (module && module.exports) {\n        module.exports = factory;\n      } // For CommonJS with exports, but without module.exports, like Rhino\n      else if (exports) {\n        exports.origami = factory;\n      } // For browser, export only select globals\n      else if (false) {\n        window.origami = extend(Origami.init.bind(Origami), Origami);\n      } // Get a reference to the global object\n\n    })(function () {\n      return this;\n    }());\n  });\n  var origami_2 = origami_1.origami;\n\n  var drawRoundLayers = functionContext => {\n    let {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper,\n      canvasId\n    } = functionContext;\n    let helper = new Helper(ctx);\n    let origamiContext = {};\n    let origami = origami_1.bind(origamiContext);\n    origami(ctx).rect(10, 10, 40, 40).draw();\n  }; //options:type,colors,stroke\n\n\n  function visualize(data, canvasId, options = {}, frame) {\n    //make a clone of options\n    options = _objectSpread({}, options); //options\n\n    if (!options.stroke) options.stroke = 1;\n    if (!options.colors) options.colors = [\"#d92027\", \"#ff9234\", \"#ffcd3c\", \"#35d0ba\"];\n    let canvas = document.getElementById(canvasId);\n    if (!canvas) return;\n    let ctx = canvas.getContext(\"2d\");\n    let h = canvas.height;\n    let w = canvas.width;\n    ctx.strokeStyle = options.colors[0];\n    ctx.lineWidth = options.stroke;\n    let typeMap = {\n      \"bars\": drawBars,\n      \"bars blocks\": drawBarsBlocks,\n      \"big bars\": drawBigBars,\n      \"cubes\": drawCubes,\n      \"dualbars\": drawDualbars,\n      \"dualbars blocks\": drawDualbarsBlocks,\n      \"fireworks\": drawFireworks,\n      \"flower\": drawFlower,\n      \"flower blocks\": drawFlowerBlocks,\n      \"orbs\": drawOrbs,\n      \"ring\": drawRing,\n      \"rings\": drawRings,\n      \"round layers\": drawRoundLayers,\n      \"round wave\": drawRoundWave,\n      \"shine\": drawShine,\n      \"shine rings\": drawShineRings,\n      \"shockwave\": drawShockwave,\n      \"star\": drawStar,\n      \"static\": drawStatic,\n      \"stitches\": drawStitches,\n      \"wave\": drawWave,\n      \"web\": drawWeb\n    };\n    let frameRateMap = {\n      \"bars\": 1,\n      \"bars blocks\": 1,\n      \"big bars\": 1,\n      \"cubes\": 1,\n      \"dualbars\": 1,\n      \"dualbars blocks\": 1,\n      \"fireworks\": 1,\n      \"flower\": 1,\n      \"flower blocks\": 1,\n      \"ring\": 1,\n      \"rings\": 1,\n      \"round layers\": 1,\n      \"round wave\": 1,\n      \"orbs\": 1,\n      \"shine\": 1,\n      \"shine rings\": 1,\n      \"shockwave\": 1,\n      \"star\": 1,\n      \"static\": 1,\n      \"stitches\": 1,\n      \"wave\": 1,\n      \"web\": 1\n    };\n    const functionContext = {\n      data,\n      options,\n      ctx,\n      h,\n      w,\n      Helper: this.Helper,\n      canvasId\n    };\n    if (typeof options.type == \"string\") options.type = [options.type];\n    options.type.forEach(type => {\n      //abide by the frame rate\n      if (frame % frameRateMap[type] === 0) {\n        //clear canvas\n        ctx.clearRect(0, 0, w, h);\n        ctx.beginPath();\n        typeMap[type](functionContext);\n      }\n    });\n  }\n\n  function Helper(ctx) {\n    this.ctx = ctx;\n    this.mainColor = \"black\";\n  }\n\n  Helper.prototype = {\n    __toRadians__(degree) {\n      return degree * Math.PI / 180;\n    },\n\n    __rotatePoint__([pointX, pointY], [originX, originY], degree) {\n      //clockwise\n      let angle = this.__toRadians__(degree);\n\n      let rotatedX = Math.cos(angle) * (pointX - originX) - Math.sin(angle) * (pointY - originY) + originX;\n      let rotatedY = Math.sin(angle) * (pointX - originX) + Math.cos(angle) * (pointY - originY) + originY;\n      return [rotatedX, rotatedY];\n    },\n\n    mutateData(data, type, extra = null) {\n      if (type === \"mirror\") {\n        let rtn = [];\n\n        for (let i = 0; i < data.length; i += 2) {\n          rtn.push(data[i]);\n        }\n\n        rtn = [...rtn, ...rtn.reverse()];\n        return rtn;\n      }\n\n      if (type === \"shrink\") {\n        //resize array by % of current array\n        if (extra < 1) {\n          extra = data.length * extra;\n        }\n\n        let rtn = [];\n        let splitAt = Math.floor(data.length / extra);\n\n        for (let i = 1; i <= extra; i++) {\n          let arraySection = data.slice(i * splitAt, i * splitAt + splitAt);\n          let middle = arraySection[Math.floor(arraySection.length / 2)];\n          rtn.push(middle);\n        }\n\n        return rtn;\n      }\n\n      if (type === \"split\") {\n        let size = Math.floor(data.length / extra);\n        let rtn = [];\n        let temp = [];\n        let track = 0;\n\n        for (let i = 0; i <= size * extra; i++) {\n          if (track === size) {\n            rtn.push(temp);\n            temp = [];\n            track = 0;\n          }\n\n          temp.push(data[i]);\n          track++;\n        }\n\n        return rtn;\n      }\n\n      if (type === \"scale\") {\n        let scalePercent = extra / 255;\n        if (extra <= 3 && extra >= 0) scalePercent = extra;\n        let rtn = data.map(value => value * scalePercent);\n        return rtn;\n      }\n\n      if (type === \"organize\") {\n        let rtn = {};\n        rtn.base = data.slice(60, 120);\n        rtn.vocals = data.slice(120, 255);\n        rtn.mids = data.slice(255, 2000);\n        return rtn;\n      }\n\n      if (type === \"reverb\") {\n        let rtn = [];\n        data.forEach((val, i) => {\n          rtn.push(val - (data[i + 1] || 0));\n        });\n        return rtn;\n      }\n\n      if (type === \"amp\") {\n        let rtn = [];\n        data.forEach(val => {\n          rtn.push(val * (extra + 1));\n        });\n        return rtn;\n      }\n\n      if (type === \"min\") {\n        let rtn = [];\n        data.forEach(value => {\n          if (value < extra) value = extra;\n          rtn.push(value);\n        });\n        return rtn;\n      }\n    },\n\n    getPoints(shape, size, [originX, originY], pointCount, endPoints, options = {}) {\n      let {\n        offset = 0,\n        rotate = 0,\n        customOrigin = []\n      } = options;\n      let rtn = {\n        start: [],\n        end: []\n      };\n\n      if (shape === \"circle\") {\n        let degreePerPoint = 360 / pointCount;\n\n        let radianPerPoint = this.__toRadians__(degreePerPoint);\n\n        let radius = size / 2;\n\n        for (let i = 1; i <= pointCount; i++) {\n          let currentRadian = radianPerPoint * i;\n          let currentEndPoint = endPoints[i - 1];\n          let pointOffset = endPoints[i - 1] * (offset / 100);\n          let x = originX + (radius - pointOffset) * Math.cos(currentRadian);\n          let y = originY + (radius - pointOffset) * Math.sin(currentRadian);\n\n          let point1 = this.__rotatePoint__([x, y], [originX, originY], rotate);\n\n          rtn.start.push(point1);\n          x = originX + (radius - pointOffset + currentEndPoint) * Math.cos(currentRadian);\n          y = originY + (radius - pointOffset + currentEndPoint) * Math.sin(currentRadian);\n\n          let point2 = this.__rotatePoint__([x, y], [originX, originY], rotate);\n\n          rtn.end.push(point2);\n        }\n\n        return rtn;\n      }\n\n      if (shape === \"line\") {\n        let increment = size / pointCount;\n        originX = customOrigin[0] || originX;\n        originY = customOrigin[1] || originY;\n\n        for (let i = 0; i <= pointCount; i++) {\n          let degree = rotate;\n          let pointOffset = endPoints[i] * (offset / 100);\n\n          let startingPoint = this.__rotatePoint__([originX + i * increment, originY - pointOffset], [originX, originY], degree);\n\n          rtn.start.push(startingPoint);\n\n          let endingPoint = this.__rotatePoint__([originX + i * increment, originY + endPoints[i] - pointOffset], [originX, originY], degree);\n\n          rtn.end.push(endingPoint);\n        }\n\n        return rtn;\n      }\n    },\n\n    drawCircle([x, y], diameter, options = {}) {\n      let {\n        color,\n        lineColor = this.ctx.strokeStyle\n      } = options;\n      this.ctx.beginPath();\n      this.ctx.arc(x, y, diameter / 2, 0, 2 * Math.PI);\n      this.ctx.strokeStyle = lineColor;\n      this.ctx.stroke();\n      this.ctx.fillStyle = color;\n      if (color) this.ctx.fill();\n    },\n\n    drawOval([x, y], height, width, options = {}) {\n      let {\n        rotation = 0,\n        color,\n        lineColor = this.ctx.strokeStyle\n      } = options;\n      if (rotation) rotation = this.__toRadians__(rotation);\n      this.ctx.beginPath();\n      this.ctx.ellipse(x, y, width, height, rotation, 0, 2 * Math.PI);\n      this.ctx.strokeStyle = lineColor;\n      this.ctx.stroke();\n      this.ctx.fillStyle = color;\n      if (color) this.ctx.fill();\n    },\n\n    drawSquare([x, y], diameter, options = {}) {\n      this.drawRectangle([x, y], diameter, diameter, options);\n    },\n\n    drawRectangle([x, y], height, width, options = {}) {\n      let {\n        color,\n        lineColor = this.ctx.strokeStyle,\n        radius = 0,\n        rotate = 0\n      } = options; // if (width < 2 * radius) radius = width / 2;\n      // if (height < 2 * radius) radius = height / 2;\n\n      this.ctx.beginPath();\n      this.ctx.moveTo(x + radius, y);\n\n      let p1 = this.__rotatePoint__([x + width, y], [x, y], rotate);\n\n      let p2 = this.__rotatePoint__([x + width, y + height], [x, y], rotate);\n\n      this.ctx.arcTo(p1[0], p1[1], p2[0], p2[1], radius);\n\n      let p3 = this.__rotatePoint__([x + width, y + height], [x, y], rotate);\n\n      let p4 = this.__rotatePoint__([x, y + height], [x, y], rotate);\n\n      this.ctx.arcTo(p3[0], p3[1], p4[0], p4[1], radius);\n\n      let p5 = this.__rotatePoint__([x, y + height], [x, y], rotate);\n\n      let p6 = this.__rotatePoint__([x, y], [x, y], rotate);\n\n      this.ctx.arcTo(p5[0], p5[1], p6[0], p6[1], radius);\n\n      let p7 = this.__rotatePoint__([x, y], [x, y], rotate);\n\n      let p8 = this.__rotatePoint__([x + width, y], [x, y], rotate);\n\n      this.ctx.arcTo(p7[0], p7[1], p8[0], p8[1], radius);\n      this.ctx.closePath();\n      this.ctx.strokeStyle = lineColor;\n      this.ctx.stroke();\n      this.ctx.fillStyle = color;\n      if (color) this.ctx.fill();\n    },\n\n    drawLine([fromX, fromY], [toX, toY], options = {}) {\n      let {\n        lineColor = this.ctx.strokeStyle\n      } = options;\n      this.ctx.beginPath();\n      this.ctx.moveTo(fromX, fromY);\n      this.ctx.lineTo(toX, toY);\n      this.ctx.strokeStyle = lineColor;\n      this.ctx.stroke();\n    },\n\n    drawPolygon(points, options = {}) {\n      let {\n        color,\n        lineColor = this.ctx.strokeStyle,\n        radius = 0,\n        close = false\n      } = options;\n\n      function getRoundedPoint(x1, y1, x2, y2, radius, first) {\n        let total = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n        let idx = first ? radius / total : (total - radius) / total;\n        return [x1 + idx * (x2 - x1), y1 + idx * (y2 - y1)];\n      }\n\n      function getRoundedPoints(pts, radius) {\n        let len = pts.length;\n        let res = new Array(len);\n\n        for (let i2 = 0; i2 < len; i2++) {\n          let i1 = i2 - 1;\n          let i3 = i2 + 1;\n          if (i1 < 0) i1 = len - 1;\n          if (i3 == len) i3 = 0;\n          let p1 = pts[i1];\n          let p2 = pts[i2];\n          let p3 = pts[i3];\n          let prevPt = getRoundedPoint(p1[0], p1[1], p2[0], p2[1], radius, false);\n          let nextPt = getRoundedPoint(p2[0], p2[1], p3[0], p3[1], radius, true);\n          res[i2] = [prevPt[0], prevPt[1], p2[0], p2[1], nextPt[0], nextPt[1]];\n        }\n\n        return res;\n      }\n\n      if (radius > 0) {\n        points = getRoundedPoints(points, radius);\n      }\n\n      let i,\n          pt,\n          len = points.length;\n\n      for (i = 0; i < len; i++) {\n        pt = points[i];\n\n        if (i == 0) {\n          this.ctx.beginPath();\n          this.ctx.moveTo(pt[0], pt[1]);\n        } else {\n          this.ctx.lineTo(pt[0], pt[1]);\n        }\n\n        if (radius > 0) {\n          this.ctx.quadraticCurveTo(pt[2], pt[3], pt[4], pt[5]);\n        }\n      }\n\n      if (close) this.ctx.closePath();\n      this.ctx.strokeStyle = lineColor;\n      this.ctx.stroke();\n      this.ctx.fillStyle = color;\n      if (color) this.ctx.fill();\n    }\n\n  };\n\n  function Wave() {\n    this.current_stream = {};\n    this.sources = {};\n    this.onFileLoad = null;\n    this.activeElements = {};\n    this.activated = false;\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n  }\n\n  Wave.prototype = _objectSpread(_objectSpread({\n    fromElement,\n    fromFile\n  }, fromStream$1), {}, {\n    visualize,\n    Helper\n  });\n  return Wave;\n}();","map":null,"metadata":{},"sourceType":"script"}